{
  "id": "./docs/en/intlayer_with_next-intl.md",
  "content": "---\ncreatedAt: 2025-10-05\nupdatedAt: 2025-10-05\ntitle: Next.js and next-intl i18n - How to translate your Next.js app – guide 2026\ndescription: Discover how to make your Next.js 15 App Router website multilingual. Follow the documentation to internationalize (i18n) and translate it.\nkeywords:\n  - Internationalization\n  - Documentation\n  - Intlayer\n  - Next.js 15\n  - next-intl\n  - JavaScript\n  - React\nslugs:\n  - doc\n  - next-intl\napplicationTemplate: https://github.com/aymericzip/intlayer-next-intl-template\n---\n\n# Translate your Next.js 15 using next-intl website using Intlayer | Internationalization (i18n)\n\nThis guide walks you through next-intl best practices in a Next.js 15 (App Router) app, and shows how to layer Intlayer on top for robust translation management and automation.\n\nSee the comparison in [next-i18next vs next-intl vs Intlayer](https://github.com/aymericzip/intlayer/blob/main/docs/blog/en/next-i18next_vs_next-intl_vs_intlayer.md).\n\n- For juniors: follow step-by-step sections to get a working multilingual app.\n- For mid-level devs: pay attention to payload optimization and server/client separation.\n- For seniors: note static generation, middleware, SEO integration, and automation hooks.\n\nWhat we’ll cover:\n\n- Setup and file structure\n- Optimizing how messages are loaded\n- Client and server component usage\n- Metadata, sitemap, robots for SEO\n- Middleware for locale routing\n- Adding Intlayer on top (CLI and automation)\n\n## Set up your application using next-intl\n\nInstall the next-intl dependencies:\n\n```bash packageManager=\"npm\"\nnpm install next-intl\n```\n\n```bash packageManager=\"pnpm\"\npnpm add next-intl\n```\n\n```bash packageManager=\"yarn\"\nyarn add next-intl\n```\n\n```bash packageManager=\"bun\"\nbun add next-intl\n```\n\n```bash\n.\n├── locales\n│   ├── en\n│   │  ├── common.json\n│   │  └── about.json\n│   ├── fr\n│   │  ├── common.json\n│   │  └── about.json\n│   └── es\n│      ├── common.json\n│      └── about.json\n└── src\n    ├── i18n.ts\n    ├── middleware.ts\n    ├── app\n    │   └── [locale]\n    │       ├── layout.tsx\n    │       └── about\n    │           └── page.tsx\n    └── components\n        ├── ClientComponentExample.tsx\n        └── ServerComponent.tsx\n```\n\n#### Setup and Loading Content\n\nLoad only the namespaces your routes need and validate locales early. Keep server components synchronous when possible and push only the required messages to the client.\n\n```tsx fileName=\"src/i18n.ts\"\nimport { getRequestConfig } from \"next-intl/server\";\nimport { notFound } from \"next/navigation\";\n\nexport const locales = [\"en\", \"fr\", \"es\"] as const;\nexport const defaultLocale = \"en\" as const;\n\nasync function loadMessages(locale: string) {\n  // Load only the namespaces your layout/pages need\n  const [common, about] = await Promise.all([\n    import(`../locales/${locale}/common.json`).then((m) => m.default),\n    import(`../locales/${locale}/about.json`).then((m) => m.default),\n  ]);\n\n  return { common, about } as const;\n}\n\nexport default getRequestConfig(async ({ locale }) => {\n  if (!locales.includes(locale as any)) notFound();\n\n  return {\n    messages: await loadMessages(locale),\n  };\n});\n```\n\n```tsx fileName=\"src/app/[locale]/layout.tsx\"\nimport type { ReactNode } from \"react\";\nimport { locales } from \"@/i18n\";\nimport {\n  getLocaleDirection,\n  unstable_setRequestLocale,\n} from \"next-intl/server\";\n\nexport const dynamic = \"force-static\";\n\nexport function generateStaticParams() {\n  return locales.map((locale) => ({ locale }));\n}\n\nexport default async function LocaleLayout({\n  children,\n  params,\n}: {\n  children: ReactNode;\n  params: { locale: string };\n}) {\n  const { locale } = params;\n\n  // Set the active request locale for this server render (RSC)\n  unstable_setRequestLocale(locale);\n\n  const dir = getLocaleDirection(locale);\n\n  return (\n    <html lang={locale} dir={dir}>\n      <body>{children}</body>\n    </html>\n  );\n}\n```\n\n```tsx fileName=\"src/app/[locale]/about/page.tsx\"\nimport { getTranslations, getMessages, getFormatter } from \"next-intl/server\";\nimport { NextIntlClientProvider } from \"next-intl\";\nimport pick from \"lodash/pick\";\nimport ServerComponent from \"@/components/ServerComponent\";\nimport ClientComponentExample from \"@/components/ClientComponentExample\";\n\nexport const dynamic = \"force-static\";\n\nexport default async function AboutPage({\n  params,\n}: {\n  params: { locale: string };\n}) {\n  const { locale } = params;\n\n  // Messages are loaded server-side. Push only what's needed to the client.\n  const messages = await getMessages();\n  const clientMessages = pick(messages, [\"common\", \"about\"]);\n\n  // Strictly server-side translations/formatting\n  const tAbout = await getTranslations(\"about\");\n  const tCounter = await getTranslations(\"about.counter\");\n  const format = await getFormatter();\n\n  const initialFormattedCount = format.number(0);\n\n  return (\n    <NextIntlClientProvider locale={locale} messages={clientMessages}>\n      <main>\n        <h1>{tAbout(\"title\")}</h1>\n        <ClientComponentExample />\n        <ServerComponent\n          formattedCount={initialFormattedCount}\n          label={tCounter(\"label\")}\n          increment={tCounter(\"increment\")}\n        />\n      </main>\n    </NextIntlClientProvider>\n  );\n}\n```\n\n### Usage in a client component\n\nLet's take an example of a client component rendering a counter.\n\n**Translations (shape reused; load them into next-intl messages as you prefer)**\n\n```json fileName=\"locales/en/about.json\"\n{\n  \"counter\": {\n    \"label\": \"Counter\",\n    \"increment\": \"Increment\"\n  }\n}\n```\n\n```json fileName=\"locales/fr/about.json\"\n{\n  \"counter\": {\n    \"label\": \"Compteur\",\n    \"increment\": \"Incrémenter\"\n  }\n}\n```\n\n**Client component**\n\n```tsx fileName=\"src/components/ClientComponentExample.tsx\"\n\"use client\";\n\nimport React, { useState } from \"react\";\nimport { useTranslations, useFormatter } from \"next-intl\";\n\nconst ClientComponentExample = () => {\n  // Scope directly to the nested object\n  const t = useTranslations(\"about.counter\");\n  const format = useFormatter();\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>{format.number(count)}</p>\n      <button\n        aria-label={t(\"label\")}\n        onClick={() => setCount((count) => count + 1)}\n      >\n        {t(\"increment\")}\n      </button>\n    </div>\n  );\n};\n```\n\n> Don't forget to add \"about\" message on the page client message\n> (only include the namespaces your client actually needs).\n\n### Usage in a server component\n\nThis UI component is a server component and can be rendered under a client component (page → client → server). Keep it synchronous by passing precomputed strings.\n\n```tsx fileName=\"src/components/ServerComponent.tsx\"\ntype ServerComponentProps = {\n  formattedCount: string;\n  label: string;\n  increment: string;\n};\n\nconst ServerComponent = ({\n  formattedCount,\n  label,\n  increment,\n}: ServerComponentProps) => {\n  return (\n    <div>\n      <p>{formattedCount}</p>\n      <button aria-label={label}>{increment}</button>\n    </div>\n  );\n};\n```\n\nNotes:\n\n- Compute `formattedCount` server-side (e.g., `const initialFormattedCount = format.number(0)`).\n- Avoid passing functions or non-serializable objects into server components.\n\n```tsx fileName=\"src/app/[locale]/about/layout.tsx\"\nimport type { Metadata } from \"next\";\nimport { locales, defaultLocale } from \"@/i18n\";\nimport { getTranslations } from \"next-intl/server\";\n\nfunction localizedPath(locale: string, path: string) {\n  return locale === defaultLocale ? path : \"/\" + locale + path;\n}\n\nexport async function generateMetadata({\n  params,\n}: {\n  params: { locale: string };\n}): Promise<Metadata> {\n  const { locale } = params;\n  const t = await getTranslations({ locale, namespace: \"about\" });\n\n  const url = \"/about\";\n  const languages = Object.fromEntries(\n    locales.map((locale) => [locale, localizedPath(locale, url)])\n  );\n\n  return {\n    title: t(\"title\"),\n    description: t(\"description\"),\n    alternates: {\n      canonical: localizedPath(locale, url),\n      languages: { ...languages, \"x-default\": url },\n    },\n  };\n}\n\n// ... Rest of the page code\n```\n\n```tsx fileName=\"src/app/sitemap.ts\"\nimport type { MetadataRoute } from \"next\";\nimport { locales, defaultLocale } from \"@/i18n\";\n\nconst origin = \"https://example.com\";\n\nconst formatterLocalizedPath = (locale: string, path: string) =>\n  locale === defaultLocale ? origin + path : origin + \"/\" + locale + path;\n\nexport default function sitemap(): MetadataRoute.Sitemap {\n  const aboutLanguages = Object.fromEntries(\n    locales.map((l) => [l, formatterLocalizedPath(l, \"/about\")])\n  );\n\n  return [\n    {\n      url: formatterLocalizedPath(defaultLocale, \"/about\"),\n      lastModified: new Date(),\n      changeFrequency: \"monthly\",\n      priority: 0.7,\n      alternates: { languages: aboutLanguages },\n    },\n  ];\n}\n```\n\n```tsx fileName=\"src/app/robots.ts\"\nimport type { MetadataRoute } from \"next\";\nimport { locales, defaultLocale } from \"@/i18n\";\n\nconst origin = \"https://example.com\";\nconst withAllLocales = (path: string) => [\n  path,\n  ...locales\n    .filter((locale) => locale !== defaultLocale)\n    .map((locale) => \"/\" + locale + path),\n];\n\nexport default function robots(): MetadataRoute.Robots {\n  const disallow = [\n    ...withAllLocales(\"/dashboard\"),\n    ...withAllLocales(\"/admin\"),\n  ];\n\n  return {\n    rules: { userAgent: \"*\", allow: [\"/\"], disallow },\n    host: origin,\n    sitemap: origin + \"/sitemap.xml\",\n  };\n}\n```\n\n### Middleware for locale routing\n\nAdd a middleware to handle locale detection and routing:\n\n```ts fileName=\"src/middleware.ts\"\nimport createMiddleware from \"next-intl/middleware\";\nimport { locales, defaultLocale } from \"@/i18n\";\n\nexport default createMiddleware({\n  locales: [...locales],\n  defaultLocale,\n  localeDetection: true,\n});\n\nexport const config = {\n  // Skip API, Next internals and static assets\n  matcher: [\"/((?!api|_next|.*\\\\..*).*)\"],\n};\n```\n\n### Best practices\n\n- **Set html `lang` and `dir`**: In `src/app/[locale]/layout.tsx`, compute `dir` via `getLocaleDirection(locale)` and set `<html lang={locale} dir={dir}>`.\n- **Split messages by namespace**: Organize JSON per locale and namespace (e.g., `common.json`, `about.json`).\n- **Minimize client payload**: On pages, send only required namespaces to `NextIntlClientProvider` (e.g., `pick(messages, ['common', 'about'])`).\n- **Prefer static pages**: Export `export const dynamic = 'force-static'` and generate static params for all `locales`.\n- **Synchronous server components**: Pass precomputed strings (translated labels, formatted numbers) rather than async calls or non-serializable functions.\n\n## Implement Intlayer on top of next-intl\n\nInstall the intlayer dependencies:\n\n```bash packageManager=\"npm\"\nnpm install intlayer @intlayer/sync-json-plugin --save-dev\n```\n\n```bash packageManager=\"yarn\"\nyarn add intlayer @intlayer/sync-json-plugin --dev\n```\n\n```bash packageManager=\"pnpm\"\npnpm add intlayer @intlayer/sync-json-plugin --save-dev\n```\n\n```bash packageManager=\"bun\"\nbun add intlayer @intlayer/sync-json-plugin --dev\nbunx intlayer init\n```\n\nCreate the intlayer configuration file:\n\n```tsx fileName=\"intlayer.config.ts\"\nimport { type IntlayerConfig, Locales } from \"intlayer\";\nimport { syncJSON } from \"@intlayer/sync-json-plugin\";\n\nconst config: IntlayerConfig = {\n  internationalization: {\n    locales: [Locales.ENGLISH, Locales.FRENCH, Locales.SPANISH],\n    defaultLocale: Locales.ENGLISH,\n  },\n  ai: {\n    apiKey: process.env.OPENAI_API_KEY,\n  },\n  plugins: [\n    // Keep your per-namespace folder structure in sync with Intlayer\n    syncJSON({\n      format: \"icu\",\n      source: ({ key, locale }) => `./locales/${locale}/${key}.json`,\n    }),\n  ],\n};\n\nexport default config;\n```\n\nAdd `package.json` scripts:\n\n```json fileName=\"package.json\"\n{\n  \"scripts\": {\n    \"i18n:fill\": \"intlayer fill\",\n    \"i18n:test\": \"intlayer test\"\n  }\n}\n```\n\nNotes:\n\n- `intlayer fill`: uses your AI provider to fill missing translations based on your configured locales.\n- `intlayer test`: checks for missing/invalid translations (use it in CI).\n\nYou can configure arguments and providers; see [Intlayer CLI](https://github.com/aymericzip/intlayer/blob/main/docs/docs/en/cli/index.md).\n",
  "createdAt": "2025-10-05",
  "updatedAt": "2025-10-05",
  "title": "Next.js and next-intl i18n - How to translate your Next.js app – guide 2026",
  "description": "Discover how to make your Next.js 15 App Router website multilingual. Follow the documentation to internationalize (i18n) and translate it.",
  "keywords": [
    "Internationalization",
    "Documentation",
    "Intlayer",
    "Next.js 15",
    "next-intl",
    "JavaScript",
    "React"
  ],
  "slugs": [
    "doc",
    "next-intl"
  ],
  "applicationTemplate": "https://github.com/aymericzip/intlayer-next-intl-template",
  "docKey": "./docs/en/intlayer_with_next-intl.md",
  "githubUrl": "https://github.com/aymericzip/intlayer/blob/main/docs/docs/en/intlayer_with_next-intl.md",
  "relativeUrl": "/doc/next-intl",
  "url": "https://intlayer.org/doc/next-intl"
}